
# WORKFLOW

## Principles
- **FIRST**: Read `.cursor/rules/MASTER.mdc` for consolidated rules overview
- **SECOND**: Read `README.md` for project overview and setup
- **THIRD**: Read `TODO.md` for current priorities and items
- **FOURTH**: Read `RELEASE.md` for target version and scope
- Propose a short action plan before coding. Request human approval when "⚠ approval".
- apply `workflow.mdc` for coding practice and `testing.mdc` for testing practice and `security.mdc`for security
- be conform to `architecture.mdc` architecture directives


## FEATURE
1. Read the target `TODO.md` item (**Next** or **Now**).
2. **Create feature branch** with `BRANCH.md` documenting plan and tasks, asking relevant question before to start
3. Post a 3–6 step plan as the first PR comment.
4. Implement with guardrails (preview, dry-run, logs).
5. **Test before commit** - ensure all changes work as expected.
6. Update `TODO.md` (check item, reference PR) and `RELEASE.md` (scope).

As a very first thing, you acknowledge the next TODO and the way you will work on it following above workflow feature. If a BRANCH is in progress you also acknowledge where you are and check the state of the code to go on.

## Guardrails
- Never perform destructive DB/system actions without "⚠ approval".
- For Playwright/Cursor, always **simulate** before executing a critical action.
- **Always test before commit** - no exceptions to this rule.
- **Use Make for testing** - always run `make test.unit` before commit (see `testing.mdc`)

## Development Conventions
- **Commits**: Conventional Commits (feat:, fix:, chore:, refactor:, docs:, test:)
- **Branches**: `feat/<slug>`, `fix/<slug>`, `boot/<slug>`. Open only one at once
- **PR**: one capability per PR; checklist; clear description (objective + short plan)
- **Never proceed more than one item of `TODO.md`**
- **Be minimalist in changes** (don't refacto the whole to avoid regressions)
- **Commit messages and PR descriptions MUST be in English**

## Commit Guidelines
- **Atomic commits** : One logical change per commit
- **File count limit** : Maximum 10-15 files per commit
- **Commit frequency** : Commit every 2-3 logical changes
- **Before major work** : Commit current progress
- **Commit message format** : `type: concise description`

### Commit Workflow (MANDATORY)
1. **Check status first** : Always run `git status` before committing
2. **Selective staging** : Use `git add <specific-files>` for files you know you modified
3. **Remove deleted files** : Use `git rm <deleted-files>` for files you know you deleted
4. **Verify staging** : Run `git status` again to confirm what's staged
5. **ABSOLUTELY NO `git add .`** : Never use `git add .` - first check with `git status` and `git add <files> && git rm <removed-files>` for explicit staging
6. **Commit with context** : Include clear description of what changed and why
7. **ONE task per commit** : Complete ONE logical task, then commit. Do NOT chain multiple tasks without committing.
8. **File count limit** : Maximum 10-15 files per commit - split large changes into multiple commits
9. **Update current work**: update BRANCH.md and commit it to be sure of remaining work at every step
10. **Consolidate CI debug commits (MANDATORY)**: When experimenting with CI workflows (e.g., tweaking `.github/workflows/*.yml`), avoid piling multiple temporary `fix:`/`test:` commits.
   - Small last-commit adjustments: prefer `git commit --amend --no-edit` (or edit message as needed).
   - Multiple debug commits: use `git commit --amend --no-edit`, stage intentionally with `git add <files> && git rm <removed-files>`, and create ONE clean commit.
   - After amending or soft reset (history rewrite), you MUST push with `git push --force-with-lease` to update the remote safely.
   This keeps the history readable and compliant with atomic commit rules.

### Next Step Proposal (MANDATORY)
After completing any task, **ALWAYS propose the next step** by following the workflow:
1. **Check current status** : What was just completed
2. **Identify next priority** : What comes next according to TODO.md or current context
3. **Propose specific action** : Clear, actionable next step
4. **Wait for approval** : Do not proceed without user confirmation

### Feature Completion Workflow (MANDATORY)
After implementing all commits for a feature:
1. **Push to GitHub** : `git push origin <branch-name>`
2. **Tech Debt**: if any component was updated, please ensure `components.mdc` was applied and update tech debt files.
2. **Final security validation** : Execute comprehensive security validation (see `security.mdc` for detailed workflow)
3. **Verify CI** : Push and Monitor GitHub Actions(using `curl` or `gh` for detailed logs) 
4. **Plan remaining actions** : If commits need additional substantial work, document in BRANCH.md - else commit --amend and git push --force <branch> until CI success
5. **Final cleanup** : When everything works:
   - Remove BRANCH.md
   - Check off feature in TODO.md
   - Update RELEASE.md
   - Create final commit with BRANCH.md content in commit message
   - Push final state
   - Create a PR if not existing and update PR message with last BRANCH.md content

### CI Monitoring (MANDATORY)
- After any push to a feature branch or PR update, automatically verify GitHub Actions runs.
- **Primary method**: use GitHub API via curl for basic status checks. Minimal, non-interactive checks:
  - Latest run for current branch:
    - `curl -s "https://api.github.com/repos/<ORG>/<REPO>/actions/runs?branch=$BRANCH&per_page=1" | grep -E '"event"|"status"|"conclusion"'`
  - Job list for a specific run id:
    - `curl -s "https://api.github.com/repos/<ORG>/<REPO>/actions/runs/<RUN_ID>/jobs" | grep -E '"name"|"conclusion"'`
- **Secondary method**: When curl is insufficient (e.g., accessing detailed logs, artifacts, or when API rate limits are hit), use `gh` CLI:
  - Install: `sudo apt install gh` or `sudo snap install gh`
  - Authenticate: `gh auth login` (requires GitHub token with `repo` and `workflow` scopes)
  - Access logs: `gh run view <RUN_ID> --log-failed` or `gh run view <RUN_ID> --log`
  - Download artifacts: `gh run download <RUN_ID>`
- If status is "skipped" unexpectedly, inspect workflow conditions/filters; for path-based workflows, ensure common files (Makefile, docker-compose.yml, packages/config, packages/schemas, CI files) are included in filters.
- If quick tweaks are needed, prefer `git commit --amend --no-edit` and push with `git push --force-with-lease`.
- If multiple debug commits were created, consolidate with `git reset --soft HEAD~N`, commit once, then `git push --force-with-lease`.
- **Push command**: Always use `git push origin <branch-name>` explicitly, never `git push --set-upstream`.

## Quality Gates
- **Before commit**: Run `make test-<service>-unit` (enforced by testing.mdc)
- **Before PR**: Run `make test` to validate consistency
- **CI/CD**: All tests must pass, guides must be consistent
- **Architecture**: Verify `make` commands work before any changes

## Feature Branch Management

### Branch Documentation
- **REQUIRED**: Create `BRANCH.md` for each feature branch (final two steps should be always test strategy completion from `testing.mdc` and Github CI execution check)
- **LOCATION**: Root of feature branch (not committed to main)
- **PURPOSE**: Track progress, plan, and commit mapping

### BRANCH.md Structure
```markdown
# Feature: [Name]

## Objective
Brief description of what this feature accomplishes

## Plan / Todo
- [ ] Task 1: Description
- [ ] Task 2: Description  
- [ ] Task 3: Description

## Commits & Progress
- [x] **Commit 1** (hash): Task 1 completed
- [x] **Commit 2** (hash): Task 2 completed
- [ ] **Commit 3**: Task 3 in progress

## Status
- **Progress**: X/Y tasks completed
- **Current**: Working on Task 3
- **Next**: Complete Task 3, then Task 4
```
