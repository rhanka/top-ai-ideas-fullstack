
# WORKFLOW

## Principles
- **FIRST**: Read `.cursor/rules/MASTER.mdc` for consolidated rules overview
- **SECOND**: Read `README.md` for project overview and setup
- **THIRD**: Read `TODO.md` for current priorities and items
- **FOURTH**: Read `BRANCH.md` if it exists (current branch plan)
- **FIFTH**: Read relevant `spec/*.md` files for the current scope
- Propose a short action plan before coding. Request human approval when "⚠ approval".
- apply `workflow.mdc` for coding practice, `testing.mdc` for testing practice, and `security.mdc` for security
- be conform to `architecture.mdc` architecture directives


## FEATURE (lean)
1. Read the target `TODO.md` item (**Next** or **Now**).
2. Create `BRANCH.md` from `BRANCH_TEMPLATE.md` and keep questions there.
3. Follow the lot-based flow in `BRANCH.md` (UAT lots → docs consolidation → final tests).
4. Constraints to enforce:
   - One migration file max in `api/drizzle/*.sql`.
   - Tests are listed exhaustively in Lot N by scope and file.
   - For complex branches, use `spec/BRANCH_SPEC_EVOL.md` (add in Lot 0, consolidate before tests, then delete).
5. Post a 3–6 step plan as the first PR comment.
6. Keep `spec/*.md` in sync with behavior changes (or note gaps in `BRANCH.md`).

### Orchestration (Conductor-style)
- Use the main agent as **orchestrator** and sub-agents only for **orthogonal tasks** (e.g., spec review, test plan review, API/UI diffs).
- Each sub-agent must work on an **isolated branch or isolated repo copy** (distinct `ENV` + ports).
- The orchestrator collects a short **decision brief** from each sub-agent (findings, risks, concrete change list).
- The orchestrator is the only one who integrates changes into the main branch.
- The orchestrator **selects the mode automatically** and records it in `BRANCH.md`:
  - **Mono-branch + cherry-pick** (single final test cycle)
  - **Multi-branch** (CI per branch, multiple test cycles)

### Multi-need, multi-branch (MANDATORY)
- When a TODO item bundles **multiple needs** (e.g., i18n + data model + print template), split into **multiple branches**, one need per branch.
- Each branch must have its own `BRANCH.md` and final tests.

### Tmp workspace option
- Sub-agents may work in `tmp/<branch-slug>/` (isolated repo copy).
- Copy `.env` into the tmp workspace before running Make commands.

As a very first thing, you acknowledge the next TODO and the way you will work on it following above workflow feature. If a BRANCH is in progress you also acknowledge where you are and check the state of the code to go on.

## Guardrails
- Never perform destructive DB/system actions without "⚠ approval".
- For Playwright/Cursor, always **simulate** before executing a critical action.
- Before each UAT lot, run `make typecheck-<ui/api>` and `make lint-<ui/api>` for impacted components.
- Before handing back to the user, run `make logs-ui` or `make logs-api` to ensure no syntax/runtime errors.
- Before handing back to the user, update the UAT checklist and test plan in `BRANCH.md` and tick completed items.

## Development Conventions
- **Commits**: Conventional Commits (feat:, fix:, chore:, refactor:, docs:, test:)
- **Branches**: `feat/<slug>`, `fix/<slug>`, `boot/<slug>`. Open only one at once
- **PR**: one capability per PR; checklist; clear description (objective + short plan)
- **Never proceed more than one item of `TODO.md`**
- **Be minimalist in changes** (don't refacto the whole to avoid regressions)
- **Commit messages and PR descriptions MUST be in English**
- **Use make targets only** (no Docker commands): `make dev` for dev, `make logs` / `make logs-<service>`, `make ps`, `make db-query`, `make exec-api` / `make exec-ui`, `make sh-<ui/api>`.
- **Do not modify `Makefile`** unless explicitly requested.
- **Compose isolation**: set `ENV=<branch-slug>` (short alias) and ensure `API_PORT`, `UI_PORT`, `MAILDEV_UI_PORT` do not conflict with other Compose projects.

## Commit Guidelines
- **Atomic commits** : One logical change per commit
- **File count limit** : Maximum 10-15 files per commit
- **Commit frequency** : Commit every 2-3 logical changes
- **Before major work** : Commit current progress
- **Commit message format** : `type: concise description`

### Commit Workflow (MANDATORY)
1. **Check status first** : Always run `git status` before committing
2. **Selective staging** : Use `git add <specific-files>` for files you know you modified or deleted, Never use `git add .` or `git add -A` (run `git status` before and after)
3. **Commit with context** : Include clear description of what changed and why
4. **ONE task per commit** : Complete ONE logical task, then commit. Do NOT chain multiple tasks without committing.
5. **Update current work**: update BRANCH.md and commit it to be sure of remaining work at every step
6. **Commit command (mandatory)**: `make commit MSG="type: concise description"` (single line only, no multiline)
7. **Consolidate CI debug commits (MANDATORY)**: Prefer `git reset --soft HEAD~N` followed by a single `make commit MSG="..."`. Avoid `git commit --amend` unless explicitly requested.

### Next Step Proposal (MANDATORY)
After completing any task, **ALWAYS propose the next step** by following the workflow:
1. **Check current status** : What was just completed
2. **Identify next priority** : What comes next according to TODO.md or current context
3. **Propose specific action** : Clear, actionable next step
4. **Wait for approval** : Do not proceed without user confirmation

### Feature Completion (aligned to BRANCH.md)
- Follow the final lots in `BRANCH.md` (tests, CI check, final cleanup).
- Final cleanup: remove `BRANCH.md`, check `TODO.md`, commit, push.

### CI Monitoring (MANDATORY)
- After any push to a feature branch or PR update, automatically verify GitHub Actions runs.
- **Primary method**: use GitHub API via curl for basic status checks. Minimal, non-interactive checks:
  - Latest run for current branch:
    - `curl -s "https://api.github.com/repos/<ORG>/<REPO>/actions/runs?branch=$BRANCH&per_page=1" | grep -E '"event"|"status"|"conclusion"'`
  - Job list for a specific run id:
    - `curl -s "https://api.github.com/repos/<ORG>/<REPO>/actions/runs/<RUN_ID>/jobs" | grep -E '"name"|"conclusion"'`
- **Secondary method**: When curl is insufficient (e.g., accessing detailed logs, artifacts, or when API rate limits are hit), use `gh` CLI:
  - Install: `sudo apt install gh` or `sudo snap install gh`
  - Authenticate: `gh auth login` (requires GitHub token with `repo` and `workflow` scopes)
  - Access logs: `gh run view <RUN_ID> --log-failed` or `gh run view <RUN_ID> --log`
  - Download artifacts: `gh run download <RUN_ID>`
- If status is "skipped" unexpectedly, inspect workflow conditions/filters; for path-based workflows, ensure common files (Makefile, docker-compose.yml, packages/config, packages/schemas, CI files) are included in filters.
- If quick tweaks are needed, prefer `git commit --amend --no-edit` and push with `git push --force-with-lease`.
- If multiple debug commits were created, consolidate with `git reset --soft HEAD~N`, commit once, then `git push --force-with-lease`.
- **Push command**: Always use `git push origin <branch-name>` explicitly, never `git push --set-upstream`.

## Quality Gates
- **Before UAT lot**: `make typecheck-<ui/api>` and `make lint-<ui/api>` for changed components
- **Before final tests**: `make build-api build-ui-image`
- **Final tests**: `make test-api`, `make test-ui`, and `make clean test-e2e`
- **CI/CD**: All tests must pass, guides must be consistent
- **Architecture**: Verify `make` commands work before any changes

## Dependency Management
- **Package-lock updates**: Always use `make update.<package>.lock` to update package-lock.json files (if implemented)
- **Docker-only**: Never run `npm install` directly - all dependency management must go through Docker
- **Available commands**: 
  - `make update.api.lock` - Update API package-lock.json (if implemented)
  - `make update.ui.lock` - Update UI package-lock.json (if implemented)
- **Clean environment**: Remove local `node_modules` if they exist outside Docker containers

## Tech-Debt Management

### Component Lifecycle Integration
- **MANDATORY**: Avoid updating components not directly related to current development (e.g don't change os and language version unless upgrade required but propose it before acting)
- **MANDATORY**: Update tech-debt files when updating components during development
- **Scope**: All component upgrades (npm, Docker images, OS versions)
- **Location**: `.components/tech-debt-<service>.md` files
- **Integration**: Tech-debt updates must be part of component upgrade workflow

### Tech-Debt Update Workflow
1. **Before upgrade**: Check current tech-debt status with `make audit-<service> COMPONENT=<component>` (e.g., `make audit-api COMPONENT=hono`) or `.components/tech-debt-<service>.md`
2. **During upgrade**: Update component version in package.json/Dockerfile
3. **After upgrade**: Update tech-debt file with new current version and re-audit
4. **Validation**: Run tests to ensure upgrade doesn't break functionality
5. **Documentation**: Update tech-debt file with new breaking change assessment

### Tech-Debt Update Commands
- **Audit current state**: Use `make audit-<service> COMPONENT=<component>` (e.g., `make audit-api COMPONENT=npm`) or check `.components/tech-debt-<service>.md` files
- **Check latest versions**: Manual review or use npm/pip commands in Docker containers
- **Update tech-debt**: Manually update `.components/tech-debt-<service>.md` files
- **Verify upgrade**: Run service tests after component upgrade

### Breaking Change Assessment
- **Major version upgrades**: Always assess for breaking changes before upgrading
- **Documentation required**: Update breaking change section in tech-debt files
- **Testing mandatory**: Run full test suite after major version upgrades
- **Rollback plan**: Document rollback strategy for major upgrades

### Quality Gates for Tech-Debt Updates
- **Before commit**: Tech-debt files must reflect current component versions
- **After upgrade**: Breaking change assessment must be updated
- **Test validation**: All tests must pass after component upgrade
- **Documentation sync**: Tech-debt files must match actual component versions

## Vulnerability Management Lifecycle

### Vulnerability Register Maintenance
- **Documentation mandatory**: All HIGH/CRITICAL/ERROR findings must be documented in `.security/vulnerability-register.yaml`
- **Categories required**: Each vulnerability must have a valid category (false_positive, accepted_risk, planned_mitigation, technical_debt)
- **Justification mandatory**: Every vulnerability must include justification for acceptance or deferral
- **Timeline required**: Fix goals must be specified (1d, 1w, 1m, 1y)

### Vulnerability Lifecycle Stages
1. **Discovery**: Found by security scans (SAST, SCA, Container, IaC)
2. **Assessment**: Categorized and risk-assessed
3. **Documentation**: Added to vulnerability register with justification
4. **Mitigation**: Fixed or accepted with timeline
5. **Verification**: Re-scanned to confirm resolution
6. **Cleanup**: Removed from register after successful mitigation

### Post-Mitigation Cleanup
- **Remove resolved vulnerabilities**: After successful fix, remove entry from vulnerability register
- **Update metadata**: Update `last_updated` timestamp in register metadata
- **Document resolution**: Add resolution details to commit message or documentation
- **Verify compliance**: Ensure all security scans pass after cleanup

### Register Maintenance Rules
- **Regular review**: Review vulnerability register monthly for outdated entries
- **Timeline validation**: Check if fix goals are realistic and achievable
- **Risk reassessment**: Periodically reassess risk levels of accepted vulnerabilities
- **Documentation updates**: Keep justifications and timelines current

### Integration with Component Lifecycle
- **Component upgrades**: When updating components, check if vulnerabilities are resolved
- **Security scans**: Run security scans after component upgrades to verify fixes
- **Tech-debt sync**: Update tech-debt files when vulnerabilities are resolved via component upgrades
- **Documentation**: Link vulnerability fixes to component upgrade commits

## Feature Branch Management
- **REQUIRED**: Create `BRANCH.md` from `BRANCH_TEMPLATE.md` for each branch.
- **LOCATION**: Repository root (not committed to main).
- **PURPOSE**: Single source of truth for plan, lots, UAT, and final gates.
