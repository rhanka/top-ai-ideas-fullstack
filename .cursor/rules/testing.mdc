# Testing Strategy

## Overview
This document defines the testing strategy for the assistant project, ensuring all testing goes through the Makefile (Docker-first approach) with optimized CI workflows.

## Testing Principles
- **Test behavior, not implementation** - Focus on what users see/do
- **Use descriptive test names** - "should [behavior] when [condition]"
- **Query by user-visible elements** - text, roles, labels over test IDs
- **Keep tests isolated** - Independent and repeatable
- **70% unit, 20% integration, 10% E2E** - Test pyramid

### Quality Gates
- All tests must pass before merge
- Security tests must pass before merge
- i18n coverage must be 100% (EN/FR parity) (to be)
- Unit test coverage: minimum 70%
- No critical security vulnerabilities without documented context
- Vulnerability assessment required for all components

## Testing commands for Development workflow (MANDATORY, following workflow)

### Main Test Commands
On TARGET=development:
- `make test-ui [SCOPE=tests/test.ts]` - UI unit tests (Vitest)
- `make test-api [SCOPE=tests/test.ts]` - API unit + integration tests (Vitest)
On TARGET=production (requires first `make build-api build-ui-image`):
- `make test-e2e [E2E_SPEC=tests/test.ts]` - E2E tests (Playwright)

### Branch Workflow Alignment
- Defer full test runs until the end of the branch to preserve user test data.
- Before each UAT lot: run `make typecheck-<ui/api>` and `make lint-<ui/api>` for impacted components.
- While developing a test, run only the test under evolution:
  - API: `make test-api-<suite> SCOPE=tests/your-file.spec.ts` (e.g., `make test-api-endpoints SCOPE=tests/organizations.spec.ts`)
  - UI: `make test-ui SCOPE=tests/your-file.spec.ts`
  - E2E: `make test-e2e E2E_SPEC=tests/your-file.spec.ts`
- Use full gates at the end: `make test-api`, `make test-ui`, and `make clean test-e2e`.
- E2E runs must be preceded by `make build-api build-ui-image`.
- Between E2E passes: run `make clean test-e2e` (clean first, then run tests).
- Update the test plan in `BRANCH.md` after each lot (what changed and what must be re-tested).
- UI testing scope: only TypeScript tests (`ui/tests/**/*.ts`), no Svelte component tests yet.
- Respect existing test structure when adding tests (`api/tests/**`, `e2e/tests/**`).

### API Test detailed Commands (with filters)
- `make test-api-smoke [SCOPE=tests/test.ts]` - API smoke tests
- `make test-api-endpoints [SCOPE=tests/test.ts]` - API CRUD tests
- `make test-api-ai [SCOPE=tests/test.ts]` - AI generation tests
- `make test-api-queue [SCOPE=tests/test.ts]` - Queue job tests
- `make test-api [SCOPE=tests/test.ts]` - All API tests (without e2e)

### UI Test Commands (pending)

### Future Security Tests (to be implemented)
- `make test-security-sast`: # SAST scanning
- `make test-security-sca`: # Dependency scanning  
- `make test-security-container`: # Container scanning
- `make test-security`: test-security-sast test-security-sca test-security-container

### Future/To be implemented:
- `make test-i18n` - i18n validation
- `make test-i18n-coverage` - Full i18n coverage
- Integration tests between UI and API

## Testing Levels

### 1. Unit Tests
- **Scope**: Individual functions, classes, components, and mock tests
- **Environment**: Isolated, no external dependencies, includes mock data/behavior
- **Includes**: Mock tests (tests bouchons) that simulate external dependencies
- **Execution**: Via `make test-ui-unit` and `make test-api-unit`
- **Frameworks**: Vitest for both UI (SvelteKit) and API (Hono)

### 2. Integration Tests
- **Scope**: API endpoints, database operations, queue processing
- **What they test**:
  - HTTP API calls and responses
  - Database CRUD operations
  - Queue job processing (QueueManager)
  - AI service integration (OpenAI)
  - Error handling and validation
- **Environment**: API service with SQLite database
- **Execution**: Via `make test-api-smoke`, `make test-api-ai`, etc.
- **File structure**: `/api/tests/` directory with organized test suites

### 3. End-to-End Tests
- **Scope**: Full user workflows across UI and API
- **Environment**: Complete stack with real services (Docker Compose)
- **Execution**: Via `make test-e2e` and `make test-smoke`
- **Framework**: Playwright for browser automation

## CI/CD Testing Strategy

### Updated CI Pipeline (High-Level)
1) Build images (Docker Compose)
- Build UI and API containers
- Run dependency audits (npm audit)

2) In parallel (no build dependency)
- Unit tests: `make test-ui-unit` and `make test-api-unit`
- Code quality: `make lint`, `make typecheck`, `make format-check`

3) After unit tests pass
- API integration tests: `make test-api-smoke`, `make test-api-ai`, etc.

4) E2E tests
- Run after integration: `make test-e2e` and `make test-smoke`

## Testing Frameworks

### Framework Selection
- **UI (SvelteKit)**: Use **Vitest** for unit tests (modern, Vite-native)
- **API (Hono)**: Use **Vitest** for unit tests (TypeScript-first, ESM support)
- **E2E**: Use **Playwright** for browser automation

## Testing Rules

### 1. No Test Duplication
- **Unit tests**: Always executed for changed components (UI/API)
- **Integration tests**: API-specific tests (database, queue, AI)
- **E2E tests**: Full user workflows across UI and API

### 2. Dependency Awareness
- **Unit tests**: Test components in isolation
- **Integration tests**: Test API interactions with external services
- **E2E tests**: Test complete user journeys
- **Configuration changes**: Trigger relevant test suites

### 3. Performance Optimization
- **Parallel execution**: UI and API unit tests run simultaneously
- **Selective testing**: Use filters for specific test suites
- **Docker caching**: Leverage Docker layer caching for faster builds

### 4. Quality Gates
- **All unit tests must pass** before integration tests
- **Integration tests must pass** before E2E tests
- **API tests**: Comprehensive coverage of endpoints, AI, and queue
- **E2E tests**: Critical user workflows validation

