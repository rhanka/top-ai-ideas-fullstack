# Testing Strategy

## Overview
This document defines the testing strategy for the assistant project, ensuring all testing goes through the Makefile (Docker-first approach) with optimized CI workflows.

## Testing Principles
- **Test behavior, not implementation** - Focus on what users see/do
- **Use descriptive test names** - "should [behavior] when [condition]"
- **Query by user-visible elements** - text, roles, labels over test IDs
- **Keep tests isolated** - Independent and repeatable
- **70% unit, 20% integration, 10% E2E** - Test pyramid

### Quality Gates
- All tests must pass before merge
- Security tests must pass before merge
- i18n coverage must be 100% (EN/FR parity) (to be)
- Unit test coverage: minimum 70%
- No critical security vulnerabilities without documented context
- Vulnerability assessment required for all components

## Testing commands for Development workflow (MANDATORY, following workflow)

### Main Test Commands
- `make test` - Run all tests (UI + API + E2E)
- `make test-ui` - UI unit tests (Vitest)
- `make test-api` - API unit tests (Vitest)
- `make test-e2e` - E2E tests (Playwright)
- `make test-smoke` - Quick smoke tests (E2E subset)

### API Test Commands (with filters)
- `make test-api-smoke [FILTER=*]` - API smoke tests
- `make test-api-endpoints [ENDPOINT=*] [METHOD=*]` - API CRUD tests
- `make test-api-ai [TYPE=*] [MODEL=*]` - AI generation tests
- `make test-api-queue [JOB_TYPE=*]` - Queue job tests
- `make test-api-all [SUITE=*]` - All API tests

### UI Test Commands (TBC)

### Future Security Tests (to be implemented)
- `make test-security-sast`: # SAST scanning
- `make test-security-sca`: # Dependency scanning  
- `make test-security-container`: # Container scanning
- `make test-security`: test-security-sast test-security-sca test-security-container

### Future/To be implemented:
- `make test-i18n` - i18n validation
- `make test-i18n-coverage` - Full i18n coverage
- Integration tests between UI and API

## Testing Levels

### 1. Unit Tests
- **Scope**: Individual functions, classes, components, and mock tests
- **Environment**: Isolated, no external dependencies, includes mock data/behavior
- **Includes**: Mock tests (tests bouchons) that simulate external dependencies
- **Execution**: Via `make test-ui-unit` and `make test-api-unit`
- **Frameworks**: Vitest for both UI (SvelteKit) and API (Hono)

### 2. Integration Tests
- **Scope**: API endpoints, database operations, queue processing
- **What they test**:
  - HTTP API calls and responses
  - Database CRUD operations
  - Queue job processing (QueueManager)
  - AI service integration (OpenAI)
  - Error handling and validation
- **Environment**: API service with SQLite database
- **Execution**: Via `make test-api-smoke`, `make test-api-ai`, etc.
- **File structure**: `/api/tests/` directory with organized test suites

### 3. End-to-End Tests
- **Scope**: Full user workflows across UI and API
- **Environment**: Complete stack with real services (Docker Compose)
- **Execution**: Via `make test-e2e` and `make test-smoke`
- **Framework**: Playwright for browser automation

## CI/CD Testing Strategy

### Updated CI Pipeline (High-Level)
1) Build images (Docker Compose)
- Build UI and API containers
- Run dependency audits (npm audit)

2) In parallel (no build dependency)
- Unit tests: `make test-ui-unit` and `make test-api-unit`
- Code quality: `make lint`, `make typecheck`, `make format-check`

3) After unit tests pass
- API integration tests: `make test-api-smoke`, `make test-api-ai`, etc.

4) E2E tests
- Run after integration: `make test-e2e` and `make test-smoke`

## Testing Frameworks

### Framework Selection
- **UI (SvelteKit)**: Use **Vitest** for unit tests (modern, Vite-native)
- **API (Hono)**: Use **Vitest** for unit tests (TypeScript-first, ESM support)
- **E2E**: Use **Playwright** for browser automation

## Testing Rules

### 1. No Test Duplication
- **Unit tests**: Always executed for changed components (UI/API)
- **Integration tests**: API-specific tests (database, queue, AI)
- **E2E tests**: Full user workflows across UI and API

### 2. Dependency Awareness
- **Unit tests**: Test components in isolation
- **Integration tests**: Test API interactions with external services
- **E2E tests**: Test complete user journeys
- **Configuration changes**: Trigger relevant test suites

### 3. Performance Optimization
- **Parallel execution**: UI and API unit tests run simultaneously
- **Selective testing**: Use filters for specific test suites
- **Docker caching**: Leverage Docker layer caching for faster builds

### 4. Quality Gates
- **All unit tests must pass** before integration tests
- **Integration tests must pass** before E2E tests
- **API tests**: Comprehensive coverage of endpoints, AI, and queue
- **E2E tests**: Critical user workflows validation

