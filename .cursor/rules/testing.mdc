# Testing Strategy

## Overview
This document defines the testing strategy for the assistant project, ensuring all testing goes through the Makefile (Docker-first approach) with optimized CI workflows.

## Testing Principles
- **Test behavior, not implementation** - Focus on what users see/do
- **Use descriptive test names** - "should [behavior] when [condition]"
- **Query by user-visible elements** - text, roles, labels over test IDs
- **Keep tests isolated** - Independent and repeatable
- **70% unit, 20% integration, 10% E2E** - Test pyramid

### Quality Gates
- All non-AI tests must pass before merge
- AI flaky allowlist tests are non-blocking when documented with failure signature and explicit user sign-off
- Security tests must pass before merge
- i18n coverage must be 100% (EN/FR parity) (to be)
- Unit test coverage: minimum 70%
- No critical security vulnerabilities without documented context
- Vulnerability assessment required for all components

## Testing commands for Development workflow (MANDATORY, following workflow)

### Main Test Commands
On TARGET=development:
- `make test-ui [SCOPE=tests/test.ts] ENV=test` - UI unit tests (Vitest)
- `make test-api [SCOPE=tests/test.ts] ENV=test` - API unit + integration tests (Vitest)
On TARGET=production (requires first `make build-api build-ui-image`):
- `make test-e2e [E2E_SPEC=tests/test.ts] API_PORT=<api_port> UI_PORT=<ui_port> MAILDEV_UI_PORT=<maildev_port> ENV=e2e` - E2E tests (Playwright)

### AI Flaky Allowlist (Non-blocking)
- API allowlist:
  - `make test-api-ai`
  - `api/tests/ai/**` (including `api/tests/ai/usecase-generation-async.test.ts`)
- E2E allowlist:
  - `e2e/tests/00-ai-generation.spec.ts`
  - `e2e/tests/03-chat.spec.ts`
  - `e2e/tests/03-chat-chrome-extension.spec.ts`
  - `e2e/tests/07_comment_assistant.spec.ts`
- Acceptance criteria for non-blocking failure:
  - Failure signature indicates provider/network/model nondeterminism.
  - Exact command + failing file + failure signature are recorded in `BRANCH.md`.
  - User sign-off is explicitly recorded before merge.

### Environment Isolation Rules (MANDATORY)
- Keep user UAT/dev on root workspace only: `~/src/top-ai-ideas-fullstack` with `ENV=dev` (default user environment, stable data).
- Develop branch changes in isolated worktrees only: `tmp/feat-<slug>` (even for a single active branch).
- Never run test campaigns on root `dev`:
  - API/UI tests run on dedicated envs (`ENV=test` or branch-specific env).
  - E2E tests run on dedicated env (`ENV=e2e`), isolated ports, isolated compose project.
- During UAT cycle:
  - code/test in `tmp/feat-<slug>`,
  - push branch,
  - switch to root workspace for user UAT on dev,
  - switch back to `tmp/feat-<slug>` for continuation.
- Command style is mandatory: `ENV` must be the last argument in all `make` commands.
  - Valid: `make test-e2e E2E_SPEC=tests/foo.spec.ts API_PORT=8788 UI_PORT=5174 MAILDEV_UI_PORT=1084 ENV=e2e`
  - Invalid: `ENV=e2e make test-e2e ...`

### Branch Workflow Alignment
- Defer full test runs until the end of the branch to preserve user test data.
- Before each UAT lot: run `make typecheck-<ui/api>` and `make lint-<ui/api>` for impacted components.
- While developing a test, run only the test under evolution:
  - API: `make test-api-<suite> SCOPE=tests/your-file.spec.ts` (e.g., `make test-api-endpoints SCOPE=tests/organizations.spec.ts`)
  - UI: `make test-ui SCOPE=tests/your-file.spec.ts`
  - E2E: `make test-e2e E2E_SPEC=tests/your-file.spec.ts`
- Use full gates at the end: `make test-api`, `make test-ui`, and `make clean test-e2e`.
- If full gates fail only inside the AI flaky allowlist, treat as non-blocking and document failure signatures in `BRANCH.md`.
- E2E runs must be preceded by `make build-api build-ui-image`.
- Between E2E passes: run `make clean ... ENV=e2e` first, then `make test-e2e ... ENV=e2e`, then `make clean ... ENV=e2e`.
- Update the test plan in `BRANCH.md` after each lot (what changed and what must be re-tested).
- UI testing scope: only TypeScript tests (`ui/tests/**/*.ts`), no Svelte component tests yet.
- Respect existing test structure when adding tests (`api/tests/**`, `e2e/tests/**`).

### BMad Alignment (process note)
- **Analysis** is performed only when explicitly requested in `TODO.md`.
- **Planning** is the lot-based `BRANCH.md` plan (already required).
- **Implementation** happens per lot.
- **QA** is covered by the final gates and UAT checkboxes.

### API Test detailed Commands (with filters)
- `make test-api-smoke [SCOPE=tests/test.ts]` - API smoke tests
- `make test-api-endpoints [SCOPE=tests/test.ts]` - API CRUD tests
- `make test-api-ai [SCOPE=tests/test.ts]` - AI generation tests
- `make test-api-queue [SCOPE=tests/test.ts]` - Queue job tests
- `make test-api [SCOPE=tests/test.ts]` - All API tests (without e2e)

### UI Test Commands (pending)

### Future Security Tests (to be implemented)
- `make test-security-sast`: # SAST scanning
- `make test-security-sca`: # Dependency scanning  
- `make test-security-container`: # Container scanning
- `make test-security`: test-security-sast test-security-sca test-security-container

### Future/To be implemented:
- `make test-i18n` - i18n validation
- `make test-i18n-coverage` - Full i18n coverage
- Integration tests between UI and API

## Testing Levels

### 1. Unit Tests
- **Scope**: Individual functions, classes, components, and mock tests
- **Environment**: Isolated, no external dependencies, includes mock data/behavior
- **Includes**: Mock tests (tests bouchons) that simulate external dependencies
- **Execution**: Via `make test-ui-unit` and `make test-api-unit`
- **Frameworks**: Vitest for both UI (SvelteKit) and API (Hono)

### 2. Integration Tests
- **Scope**: API endpoints, database operations, queue processing
- **What they test**:
  - HTTP API calls and responses
  - Database CRUD operations
  - Queue job processing (QueueManager)
  - AI service integration (OpenAI)
  - Error handling and validation
- **Environment**: API service with SQLite database
- **Execution**: Via `make test-api-smoke`, `make test-api-ai`, etc.
- **File structure**: `/api/tests/` directory with organized test suites

### 3. End-to-End Tests
- **Scope**: Full user workflows across UI and API
- **Environment**: Complete stack with real services (Docker Compose)
- **Execution**: Via `make test-e2e` and `make test-smoke`
- **Framework**: Playwright for browser automation

## CI/CD Testing Strategy

### Updated CI Pipeline (High-Level)
1) Build images (Docker Compose)
- Build UI and API containers
- Run dependency audits (npm audit)

2) In parallel (no build dependency)
- Unit tests: `make test-ui-unit` and `make test-api-unit`
- Code quality: `make lint`, `make typecheck`, `make format-check`

3) After unit tests pass
- API integration tests: `make test-api-smoke`, `make test-api-ai`, etc.

4) E2E tests
- Run after integration: `make test-e2e` and `make test-smoke`

## Testing Frameworks

### Framework Selection
- **UI (SvelteKit)**: Use **Vitest** for unit tests (modern, Vite-native)
- **API (Hono)**: Use **Vitest** for unit tests (TypeScript-first, ESM support)
- **E2E**: Use **Playwright** for browser automation

## Testing Rules

### 1. No Test Duplication
- **Unit tests**: Always executed for changed components (UI/API)
- **Integration tests**: API-specific tests (database, queue, AI)
- **E2E tests**: Full user workflows across UI and API

### 2. Dependency Awareness
- **Unit tests**: Test components in isolation
- **Integration tests**: Test API interactions with external services
- **E2E tests**: Test complete user journeys
- **Configuration changes**: Trigger relevant test suites

### 3. Performance Optimization
- **Parallel execution**: UI and API unit tests run simultaneously
- **Selective testing**: Use filters for specific test suites
- **Docker caching**: Leverage Docker layer caching for faster builds

### 4. Quality Gates
- **All unit tests must pass** before integration tests
- **Integration tests must pass** before E2E tests (except documented AI allowlist flakiness)
- **API tests**: Comprehensive coverage of endpoints, AI, and queue
- **E2E tests**: Critical user workflows validation (AI allowlist failures can be accepted as non-blocking with explicit traceability)
